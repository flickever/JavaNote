# 数仓建模理论

## 数仓分层

ODS：原始数据层，存放原始数据，直接加载原始日志、数据，数据保持原貌不做处理

DWD层：对ODS层数据进行清洗（去除空值，脏数据，超过极限范围的数据）、脱敏等。保存业务事实明细，一行信息代表一次业务行为，例如一次下单

DIM层：维度层，保存维度数据，主要是对业务试试的描述信息，例如什么人、什么时间、什么地点等

DWS层：以DWD为基础，每天进行轻度汇总。一行信息代表一个主题对象一天的汇总行为，例如一个用户一天下单次数

DWT层：以DWS为基础，对数据进行累积汇总。一行信息代表一个主题对象的累积行为，例如一个用户从注册那天开始至今一共下了多少次单

ADS层：为各种统计报表提供数据



**为什么分层**

- 复杂问题简单化，每一层只处理简单的任务，方便定位问题
- 减少重复开发，通过中间层数据，增加一次计算结果的复用性
- 隔离原始数据，是真实数据与统计数据解耦



**数据仓库与数据集市区别**

数仓是企业级别，

数据集市是部门级别，具有更少主题区域，更少数据

- 从属型数据集市：数据来自于数据仓库（搭建慢，一致性高）
- 独立型数据集市：没有数据仓库，数据来自业务系统（搭建快，一致性低）



## 关系建模

数据建模必须遵循一定的规则，在关系建模中，这种规则就是范式。

采用范式，可以降低数据的冗余性。同时防止改一次数据要改多个表

**缺点：**获取数据时，需要通过Join拼接出最后的数据，导致性能降低

目前业界范式有：第一范式(1NF)、第二范式(2NF)、第三范式(3NF)、巴斯-科德范式(BCNF)、第四范式(4NF)、第五范式(5NF)。



**函数依赖**

范式建模其实是以极强的数据理论为基础的，这里先大致了解下函数依赖是什么意思

- 完全函数依赖

```
z = f(x, y)
```

表示只有x和y同时存在才能推导出结果z

如果出现`z =f(x, )`或`z =f(, y)`就不是完全函数依赖

例如：只有用  (学号 ，课程)  才能得到分数



- 部分函数依赖

```
z = f(x, y)
z = f(x, y, n)
```

比如可以通过`x`和`y`就能推导出`z`，这时有又加了一个条件`n`

即：`z`部分依赖于`x y n`

例如：（学号，课程）推导出姓名，但实际只用学号就能推导出来



- 传递函数依赖

```
y = f(x)
z = g(y)
```

`x`不能直接算出`z`

需要先算出`y`,再通过`y`算出`z`

例如：学号 -> 系名，系名 ->系主任，系主任传递依赖于学号



**三范式建模**

1. 第一范式：属性不可切割

反例（商品字段非原子数据）

|  ID  |  商品   | 商户ID | 用户ID |
| :--: | :-----: | :----: | :----: |
| 001  | 5台电脑 |  999   |  0001  |

正例

|  ID  | 商品 | 数量 | 商户ID | 用户ID |
| :--: | :--: | :--: | :----: | :----: |
| 001  | 电脑 |  5   |  999   |  0001  |

第一范式是所有关系型数据库的基本要求



2. 第二范式：不能存在部分函数依赖（非主键字段部份依赖主键）

| 学号 | 姓名 |  系名  | 系主任 | 课程 | 分数 |
| :--: | :--: | :----: | :----: | :--: | :--: |
| 001  | 小明 | 经济系 |  王强  | 数学 |  95  |
| 001  | 小明 | 经济系 |  王强  | 语文 |  85  |
| 001  | 小明 | 经济系 |  王强  | 化学 |  90  |

上表主键是（学号，课程），姓名确实依赖于学号，课程），但并不是完全依赖



3. 第三范式：不能存在传递依赖

例如上表，：学号 -> 系名，系名 ->系主任，系主任传递依赖于学号



**关系建模与维度建模**

关系建模将复杂的数据抽象为两个概念——实体和关系，并使用规范化的方式表示出来。关系模型较为松散、零碎，物理表数量多。

关系模型严格遵循第三范式（3NF），数据冗余程度低，数据的一致性容易得到保证。由于数据分布于众多的表中，查询会相对复杂，在大数据的场景下，查询效率相对较低。（**在MR过程中，join越多，shuffle过程就越多**）

维度模型以数据分析作为出发点，不遵循三范式，故数据存在一定的冗余。维度模型面向业务，将业务用事实表和维度表呈现出来。表结构简单，故查询简单，查询效率较高。

业务事实存储在事实表当中，而维度表存储的是这些事实的描述性数据



## 事实表和维度表

**维度表**

**维度表**：一般是对事实的**描述信息**。每一张维表对应现实世界中的一个对象或者概念。   例如：用户、商品、日期、地区等。

- 维表的范围很宽（具有多个属性、列比较多）
- 跟事实表相比，行数相对较小：通常< 10万条
- 内容相对固定：编码表



**事实表**

**事实表中的每行数据代表一个业务事件（下单、支付、退款、评价等）**

每一个事实表的行包括：具有可加性的数值型的度量值、与维表相连接的外键，通常具有两个和两个以上的外键。

- 非常的大
- 内容相对的窄：列数较少（主要是外键id和度量值）
- 经常发生变化，每天会新增加很多。



1. **事务型事实表**：以**每个事务或事件为单位**，例如一个销售订单记录，一笔支付记录等，作为事实表里的一行数据。一旦事务被提交，事实表数据被插入，数据就不再进行更改，其更新方式为增量更新。

2. **周期型快照事实表**：**不会保留所有数据（不会保留所有业务操作，与事务事实表相反）**，**只保留固定时间间隔的数据**，例如每天或者每月的销售额，或每月的账户余额等；例如购物车，有加减商品，随时都有可能变化，但是我们更关心每天结束时这里面有多少商品，方便我们后期统计分析。**一般是全量同步**

3. **累积型快照事实表**：**累计快照事实表用于跟踪业务事实的变化**，会发生周期型业务，例如，数据仓库中可能需要累积或者存储订单从下订单开始，到订单商品被打包、运输、和签收的各个业务阶段的时间点数据来跟踪订单声明周期的进展情况。当这个业务过程进行时，事实表的记录也要不断更新。**同步策略：新增及变化同步（业务时间选第一个或最后一个时间）**

累积快照事实表：

| 订单ID | 用户ID | 下单时间 | 打包时间 | 发货时间 | 签收时间 | 订单金额 |
| :----: | :----: | :------: | :------: | :------: | :------: | :------: |
|        |        |   3-8    |   3-8    |   3-9    |   3-10   |          |



**维度模型分类**

雪花模型与星型模型的区别在于维度的层级，标准的星型模型维度只有一层，而雪花模型可能会有多级

雪花模型比较靠近3NF，但是无法完全遵守，因为遵守3NF性能成本太大

星座模型：与前两种的情况区别在于事实表数量，星座模型基于多个事实表星座模型不与前两个模型冲突



## 数据仓库建模

#### ODS层

用户行为数据：只有一个String字段，存埋点产生的行为数据，按天增量抽取

业务数据：建模和MySQL中表一致，按天分区

总结：数据形式决定ODS表的形式



#### DIM层和DWD层

DIM层DWD层需构建维度模型，一般采用星型模型，呈现的状态一般为星座模型。

维度建模一般按照以下四个步骤：

**选择业务过程→声明粒度→确认维度→确认事实**



**选择业务过程**

在业务系统中，挑选我们感兴趣的业务线，比如下单业务，支付业务，退款业务，物流业务，一条业务线对应一张事实表。



**声明粒度**

尽可能选择**最小粒度**，以此来应各种各样的需求。



**确认维度**

确定维度的原则是：后续需求中是否要分析相关维度的指标。例如，需要统计，什么时间下的订单多，哪个地区下的订单多，哪个用户下的订单多。需要确定的维度就包括：时间维度、地区维度、用户维度。



**确定事实**

此处的“事实”一词，指的是业务中的度量值（次数、个数、件数、金额，可以进行累加），例如订单金额、下单次数等。

在DWD层，以**业务过程**为建模驱动，基于每个具体业务过程的特点，构建**最细粒度**的明细层事实表。事实表可做适当的宽表化处理。

事实表和维度表的关联比较灵活，但是为了应对更复杂的业务需求，可以将能关联上的表尽量关联上。

|                      | **时间** | **用户** | **地区** | **商品** | **优惠券** | **活动** | **度量值**                |
| -------------------- | -------------- | -------------- | -------------- | -------------- | ---------------- | -------------- | ------------------------------- |
| **订单**       | √              | √              | √              |                |                  |                | 运费/优惠金额/原始金额/最终金额 |
| **订单详情**   | √              | √              | √              | √              | √                | √              | 件数/优惠金额/原始金额/最终金额 |
| **支付**       | √              | √              | √              |                |                  |                | 支付金额                        |
| **加购**       | √              | √              |                | √              |                  |                | 件数/金额                       |
| **收藏**       | √              | √              |                | √              |                  |                | 次数                            |
| **评价**       | √              | √              |                | √              |                  |                | 次数                            |
| **退单**       | √              | √              | √              | √              |                  |                | 件数/金额                       |
| **退款**       | √              | √              | √              | √              |                  |                | 件数/金额                       |
| **优惠券领用** | √              | √              |                |                | √                |                | 次数                            |

至此，数据仓库的维度建模已经完毕，DWD层是以业务过程为驱动。

DWS层、DWT层和ADS层都是以需求为驱动，和维度建模已经没有关系了。

DWS和DWT都是建宽表，按照主题去建表。主题相当于观察问题的角度。对应着维度表。



**保留历史数据的好处**：可看数据随时间的变化，多了一个观察数据方向、数据分析维度（时间）

**确认维度的方法**：看业务系统中表之间有没有关系



#### DWS层

需要建哪些宽表：以维度为基准。

宽表里面的字段：是站在不同维度的角度去看事实表，重点关注事实表聚合后的度量值。

**DWS和DWT层的区别**：DWS层存放的所有主题对象当天的汇总行为，例如每个地区当天的下单次数，下单金额等，DWT层存放的是所有主题对象的累积行为，例如每个地区最近７天（１５天、３０天、６０天）的下单次数、下单金额等。

